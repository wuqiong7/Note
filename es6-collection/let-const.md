##ES6笔记(let / const)

> IIFE:立即执行函数

### 不可重复性

const声明的常量，也与let一样不可重复声明

````
var message = "Hello!";
let age = 25;

// 以下两行都会报错
const message = "Goodbye!";
const age = 30;
````

### 块级作用域

````
{{{{
  {let insane = 'Hello World'}
  console.log(insane); // 报错
}}}};

````

### **const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址不得改动**
> 对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。
但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指针，
const只能保证这个指针是固定的，至于它指向的数据结构是不是可变的，就完全不能控制了。
因此，将一个对象声明为常量必须非常小心。





**如果真的想将对象冻结，则使用Object.freeze方法**

````
const a = [];
a.push('Hello'); // 可执行
a.length = 0;    // 可执行
a = ['Dave'];    // 报错


const foo = Object.freeze({});
// 常规模式时，下面一行不起作用；
// 严格模式时，该行会报错
foo.prop = 123;
````


### 声明变量方式(ES6)

- var
- function
- let
- const
- class
- import



**顶层对象，在浏览器环境指的是window对象，在Node指的是global对象。**

> 顶层对象的属性与全局变量挂钩，被认为是JavaScript语言最大的设计败笔之一。
> 这样的设计带来了几个很大的问题，首先是没法在编译时就报出变量未声明的错误，
> 只有运行时才能知道（因为全局变量可能是顶层对象的属性创造的，而属性的创造是动态的）；
> 其次，程序员很容易不知不觉地就创建了全局变量（比如打字出错）；最后，顶层对象的属性是到处可以读写的，这非常不利于模块化编程。
> 另一方面，window对象有实体含义，指的是浏览器的窗口对象，顶层对象是一个有实体含义的对象，也是不合适的。




